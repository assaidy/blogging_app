// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repositry

import (
	"context"
	"database/sql"
	"time"
)

const checkBookmark = `-- name: CheckBookmark :one
SELECT EXISTS(SELECT 1 FROM bookmarks WHERE user_id = $1 AND post_id = $2)
`

type CheckBookmarkParams struct {
	UserID string
	PostID string
}

func (q *Queries) CheckBookmark(ctx context.Context, arg CheckBookmarkParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkBookmark, arg.UserID, arg.PostID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkComment = `-- name: CheckComment :one
SELECT EXISTS(select 1 FROM post_comments WHERE id = $1)
`

func (q *Queries) CheckComment(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkComment, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkFollow = `-- name: CheckFollow :one
SELECT EXISTS(SELECT 1 FROM follows WHERE follower_id = $1 AND followed_id = $2)
`

type CheckFollowParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) CheckFollow(ctx context.Context, arg CheckFollowParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkFollow, arg.FollowerID, arg.FollowedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkNotificationForUser = `-- name: CheckNotificationForUser :one
SELECT EXISTS(SELECT 1 FROM notifications WHERE id = $1 AND user_id = $2)
`

type CheckNotificationForUserParams struct {
	ID     string
	UserID string
}

func (q *Queries) CheckNotificationForUser(ctx context.Context, arg CheckNotificationForUserParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkNotificationForUser, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPost = `-- name: CheckPost :one
SELECT EXISTS(select 1 FROM posts WHERE id = $1)
`

func (q *Queries) CheckPost(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkPost, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkReaction = `-- name: CheckReaction :one
SELECT EXISTS(SELECT 1 FROM post_reactions WHERE post_id = $1 AND user_id = $2)
`

type CheckReactionParams struct {
	PostID string
	UserID string
}

func (q *Queries) CheckReaction(ctx context.Context, arg CheckReactionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkReaction, arg.PostID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserID = `-- name: CheckUserID :one
SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)
`

func (q *Queries) CheckUserID(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserOwnsComment = `-- name: CheckUserOwnsComment :one
SELECT EXISTS(select 1 FROM post_comments WHERE id = $1 AND user_id = $2)
`

type CheckUserOwnsCommentParams struct {
	ID     string
	UserID string
}

func (q *Queries) CheckUserOwnsComment(ctx context.Context, arg CheckUserOwnsCommentParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserOwnsComment, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserOwnsPost = `-- name: CheckUserOwnsPost :one
SELECT EXISTS(select 1 FROM posts WHERE id = $1 AND user_id = $2)
`

type CheckUserOwnsPostParams struct {
	ID     string
	UserID string
}

func (q *Queries) CheckUserOwnsPost(ctx context.Context, arg CheckUserOwnsPostParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserOwnsPost, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsername = `-- name: CheckUsername :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = $1)
`

func (q *Queries) CheckUsername(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUsername, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBookmark = `-- name: CreateBookmark :exec

INSERT INTO bookmarks(user_id, post_id)
VALUES($1, $2)
ON CONFLICT(user_id, post_id) DO NOTHING
`

type CreateBookmarkParams struct {
	UserID string
	PostID string
}

// ====================================================================================================
// bookmarks
// ====================================================================================================
func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, createBookmark, arg.UserID, arg.PostID)
	return err
}

const createComment = `-- name: CreateComment :one

INSERT INTO post_comments(id, post_id, user_id, content)
VALUES($1, $2, $3, $4)
RETURNING id, post_id, user_id, content, created_at
`

type CreateCommentParams struct {
	ID      string
	PostID  string
	UserID  string
	Content string
}

// ====================================================================================================
// comments
// ====================================================================================================
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.ID,
		arg.PostID,
		arg.UserID,
		arg.Content,
	)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createDislike = `-- name: CreateDislike :exec
insert into post_reactions(post_id, user_id, kind)
VALUES($1, $2, 'dislike')
ON CONFLICT(post_id, user_id) DO UPDATE 
SET kind = EXCLUDED.kind, created_at = NOW()
`

type CreateDislikeParams struct {
	PostID string
	UserID string
}

func (q *Queries) CreateDislike(ctx context.Context, arg CreateDislikeParams) error {
	_, err := q.db.ExecContext(ctx, createDislike, arg.PostID, arg.UserID)
	return err
}

const createFollow = `-- name: CreateFollow :exec

INSERT INTO follows(follower_id, followed_id)
VALUES($1, $2)
ON CONFLICT(follower_id, followed_id) DO NOTHING
`

type CreateFollowParams struct {
	FollowerID string
	FollowedID string
}

// ====================================================================================================
// follows
// ====================================================================================================
func (q *Queries) CreateFollow(ctx context.Context, arg CreateFollowParams) error {
	_, err := q.db.ExecContext(ctx, createFollow, arg.FollowerID, arg.FollowedID)
	return err
}

const createLike = `-- name: CreateLike :exec
insert into post_reactions(post_id, user_id, kind)
VALUES($1, $2, 'like')
ON CONFLICT(post_id, user_id) DO UPDATE 
SET kind = EXCLUDED.kind, created_at = NOW()
`

type CreateLikeParams struct {
	PostID string
	UserID string
}

// ====================================================================================================
// reactions
// ====================================================================================================
func (q *Queries) CreateLike(ctx context.Context, arg CreateLikeParams) error {
	_, err := q.db.ExecContext(ctx, createLike, arg.PostID, arg.UserID)
	return err
}

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications(id, kind_id, user_id, sender_id, post_id, is_read)
VALUES($1, $2, $3, $4, $5, $6)
RETURNING id, kind_id, user_id, sender_id, post_id, is_read, created_at
`

type CreateNotificationParams struct {
	ID       string
	KindID   int32
	UserID   string
	SenderID interface{}
	PostID   interface{}
	IsRead   bool
}

// ====================================================================================================
// notifications
// ====================================================================================================
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.ID,
		arg.KindID,
		arg.UserID,
		arg.SenderID,
		arg.PostID,
		arg.IsRead,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.KindID,
		&i.UserID,
		&i.SenderID,
		&i.PostID,
		&i.IsRead,
		&i.CreatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts(id, user_id, title, content, featured_image_url)
VALUES($1, $2, $3, $4, $5)
RETURNING id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
`

type CreatePostParams struct {
	ID               string
	UserID           string
	Title            string
	Content          string
	FeaturedImageUrl sql.NullString
}

// ====================================================================================================
// posts
// ====================================================================================================
func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Content,
		arg.FeaturedImageUrl,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.ViewsCount,
		&i.CommentsCount,
		&i.FeaturedImageUrl,
	)
	return i, err
}

const createReaction = `-- name: CreateReaction :exec
INSERT INTO post_reactions(post_id, user_id, kind_id)
VALUES($1, $2, $3)
ON CONFLICT(post_id, user_id) DO UPDATE
SET kind_id = EXCLUDED.kind_id
`

type CreateReactionParams struct {
	PostID string
	UserID string
	KindID int32
}

func (q *Queries) CreateReaction(ctx context.Context, arg CreateReactionParams) error {
	_, err := q.db.ExecContext(ctx, createReaction, arg.PostID, arg.UserID, arg.KindID)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec

INSERT INTO refresh_tokens(token, user_id, expires_at)
VALUES($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	Token     string
	UserID    string
	ExpiresAt time.Time
}

// ====================================================================================================
// tokens
// ====================================================================================================
func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshToken, arg.Token, arg.UserID, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users(id, name, username, hashed_password, profile_image_url)
VALUES($1, $2, $3, $4, $5)
RETURNING id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url
`

type CreateUserParams struct {
	ID              string
	Name            string
	Username        string
	HashedPassword  string
	ProfileImageUrl sql.NullString
}

// ====================================================================================================
// users
// ====================================================================================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Username,
		arg.HashedPassword,
		arg.ProfileImageUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE user_id = $1 AND post_id = $2
`

type DeleteBookmarkParams struct {
	UserID string
	PostID string
}

func (q *Queries) DeleteBookmark(ctx context.Context, arg DeleteBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, deleteBookmark, arg.UserID, arg.PostID)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM post_comments WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const deleteFollow = `-- name: DeleteFollow :exec
DELETE FROM follows WHERE follower_id = $1 AND followed_id = $2
`

type DeleteFollowParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) DeleteFollow(ctx context.Context, arg DeleteFollowParams) error {
	_, err := q.db.ExecContext(ctx, deleteFollow, arg.FollowerID, arg.FollowedID)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const deleteReaction = `-- name: DeleteReaction :exec
DELETE FROM post_reactions WHERE post_id = $1 AND user_id = $2
`

type DeleteReactionParams struct {
	PostID string
	UserID string
}

func (q *Queries) DeleteReaction(ctx context.Context, arg DeleteReactionParams) error {
	_, err := q.db.ExecContext(ctx, deleteReaction, arg.PostID, arg.UserID)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens WHERE token = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteRefreshToken, token)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAllFollowersIDs = `-- name: GetAllFollowersIDs :many
SELECT follower_id FROM follows WHERE followed_id = $1
`

func (q *Queries) GetAllFollowersIDs(ctx context.Context, followedID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllFollowersIDs, followedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var follower_id string
		if err := rows.Scan(&follower_id); err != nil {
			return nil, err
		}
		items = append(items, follower_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarks = `-- name: GetBookmarks :many
SELECT posts.id, posts.user_id, posts.title, posts.content, posts.created_at, posts.views_count, posts.comments_count, posts.featured_image_url
FROM bookmarks
JOIN posts ON bookmarks.post_id = posts.id
WHERE bookmarks.user_id = $1
ORDER BY bookmarks.created_at
LIMIT $2
OFFSET $3
`

type GetBookmarksParams struct {
	UserID string
	Limit  int32
	Offset int32
}

func (q *Queries) GetBookmarks(ctx context.Context, arg GetBookmarksParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarks, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarksCount = `-- name: GetBookmarksCount :one
SELECT COUNT(*) FROM bookmarks WHERE user_id = $1
`

func (q *Queries) GetBookmarksCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBookmarksCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFollowers = `-- name: GetFollowers :many
SELECT users.id, users.name, users.username, users.hashed_password, users.joined_at, users.posts_count, users.following_count, users.followers_count, users.profile_image_url
FROM follows
JOIN users ON follows.follower_id = users.id
WHERE followed_id = $1
ORDER by follows.created_at
LIMIT $2
OFFSET $3
`

type GetFollowersParams struct {
	FollowedID string
	Limit      int32
	Offset     int32
}

func (q *Queries) GetFollowers(ctx context.Context, arg GetFollowersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, arg.FollowedID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.HashedPassword,
			&i.JoinedAt,
			&i.PostsCount,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowersCount = `-- name: GetFollowersCount :one
SELECT COUNT(*) FROM follows WHERE followed_id = $1
`

func (q *Queries) GetFollowersCount(ctx context.Context, followedID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowersCount, followedID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNotifications = `-- name: GetNotifications :many
SELECT 
    n.id,
    nk.name as kind,
    n.user_id,
    n.sender_id,
    n.post_id,
    n.is_read,
    n.created_at
FROM notifications n
JOIN notification_kinds nk ON nk.id = n.kind_id
WHERE n.user_id = $1
ORDER BY n.created_at DESC
LIMIT $2
OFFSET $3
`

type GetNotificationsParams struct {
	UserID string
	Limit  int32
	Offset int32
}

type GetNotificationsRow struct {
	ID        string
	Kind      string
	UserID    string
	SenderID  interface{}
	PostID    interface{}
	IsRead    bool
	CreatedAt time.Time
}

func (q *Queries) GetNotifications(ctx context.Context, arg GetNotificationsParams) ([]GetNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsRow
	for rows.Next() {
		var i GetNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.UserID,
			&i.SenderID,
			&i.PostID,
			&i.IsRead,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsCount = `-- name: GetNotificationsCount :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1
`

func (q *Queries) GetNotificationsCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPost = `-- name: GetPost :one
SELECT id, user_id, title, content, created_at, views_count, comments_count, featured_image_url FROM posts WHERE id = $1
`

func (q *Queries) GetPost(ctx context.Context, id string) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.ViewsCount,
		&i.CommentsCount,
		&i.FeaturedImageUrl,
	)
	return i, err
}

const getPostComments = `-- name: GetPostComments :many
SELECT id, post_id, user_id, content, created_at
FROM post_comments
WHERE post_id = $1
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type GetPostCommentsParams struct {
	PostID string
	Limit  int32
	Offset int32
}

func (q *Queries) GetPostComments(ctx context.Context, arg GetPostCommentsParams) ([]PostComment, error) {
	rows, err := q.db.QueryContext(ctx, getPostComments, arg.PostID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostComment
	for rows.Next() {
		var i PostComment
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostCommentsCount = `-- name: GetPostCommentsCount :one
SELECT comments_count FROM posts WHERE id = $1
`

func (q *Queries) GetPostCommentsCount(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPostCommentsCount, id)
	var comments_count int32
	err := row.Scan(&comments_count)
	return comments_count, err
}

const getPostReactions = `-- name: GetPostReactions :many
SELECT 
    rk.name,
    COUNT(pr.kind_id) AS count
FROM post_reactions pr
JOIN reaction_kinds rk ON pr.kind_id = rk.id
WHERE pr.post_id = $1
GROUP BY pr.kind_id
`

type GetPostReactionsRow struct {
	Name  string
	Count int64
}

func (q *Queries) GetPostReactions(ctx context.Context, postID string) ([]GetPostReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostReactions, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostReactionsRow
	for rows.Next() {
		var i GetPostReactionsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostViews = `-- name: GetPostViews :many
SELECT users.id, users.name, users.username, users.hashed_password, users.joined_at, users.posts_count, users.following_count, users.followers_count, users.profile_image_url
FROM post_views
JOIN users ON post_views.user_id = users.id
WHERE post_id = $1
ORDER BY post_views.created_at
LIMIT $2
OFFSET $3
`

type GetPostViewsParams struct {
	PostID string
	Limit  int32
	Offset int32
}

func (q *Queries) GetPostViews(ctx context.Context, arg GetPostViewsParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getPostViews, arg.PostID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.HashedPassword,
			&i.JoinedAt,
			&i.PostsCount,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostViewsCount = `-- name: GetPostViewsCount :one
SELECT views_count FROM posts WHERE id = $1
`

func (q *Queries) GetPostViewsCount(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPostViewsCount, id)
	var views_count int32
	err := row.Scan(&views_count)
	return views_count, err
}

const getReactionKindIDByName = `-- name: GetReactionKindIDByName :one
SELECT id FROM reaction_kinds WHERE name = $1
`

func (q *Queries) GetReactionKindIDByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getReactionKindIDByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT token, user_id, created_at, expires_at FROM refresh_tokens WHERE token = $1
`

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (RefreshToken, error) {
	row := q.db.QueryRowContext(ctx, getRefreshToken, token)
	var i RefreshToken
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUnreadNotificationsCount = `-- name: GetUnreadNotificationsCount :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1 AND is_read = false
`

func (q *Queries) GetUnreadNotificationsCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url FROM users WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const getUserPosts = `-- name: GetUserPosts :many
SELECT id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
FROM posts
WHERE user_id = $1
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type GetUserPostsParams struct {
	UserID string
	Limit  int32
	Offset int32
}

func (q *Queries) GetUserPosts(ctx context.Context, arg GetUserPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getUserPosts, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPostsCount = `-- name: GetUserPostsCount :one
SELECT posts_count FROM users WHERE id = $1
`

func (q *Queries) GetUserPostsCount(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserPostsCount, id)
	var posts_count int32
	err := row.Scan(&posts_count)
	return posts_count, err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications SET is_read = true WHERE id = $1
`

func (q *Queries) MarkNotificationAsRead(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markNotificationAsRead, id)
	return err
}

const updateComment = `-- name: UpdateComment :one
UPDATE post_comments
SET content = $1
WHERE id = $2
RETURNING id, post_id, user_id, content, created_at
`

type UpdateCommentParams struct {
	Content string
	ID      string
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, updateComment, arg.Content, arg.ID)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET 
    title = $1,
    content = $2,
    featured_image_url = $3
WHERE id = $4
RETURNING id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
`

type UpdatePostParams struct {
	Title            string
	Content          string
	FeaturedImageUrl sql.NullString
	ID               string
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.Title,
		arg.Content,
		arg.FeaturedImageUrl,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.ViewsCount,
		&i.CommentsCount,
		&i.FeaturedImageUrl,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    name = $1,
    username = $2,
    hashed_password = $3,
    profile_image_url = $4
WHERE id = $5
RETURNING id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url
`

type UpdateUserParams struct {
	Name            string
	Username        string
	HashedPassword  string
	ProfileImageUrl sql.NullString
	ID              string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Username,
		arg.HashedPassword,
		arg.ProfileImageUrl,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const viewPost = `-- name: ViewPost :exec

INSERT INTO post_views(post_id, user_id)
VALUES($1, $2)
ON CONFLICT(post_id, user_id) DO NOTHING
`

type ViewPostParams struct {
	PostID string
	UserID string
}

// ====================================================================================================
// views
// ====================================================================================================
func (q *Queries) ViewPost(ctx context.Context, arg ViewPostParams) error {
	_, err := q.db.ExecContext(ctx, viewPost, arg.PostID, arg.UserID)
	return err
}
