// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user.sql

package postgres_repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkFollow = `-- name: CheckFollow :one
SELECT EXISTS(SELECT 1 FROM follows WHERE follower_id = $1 AND followed_id = $2)
`

type CheckFollowParams struct {
	FollowerID uuid.UUID
	FollowedID uuid.UUID
}

func (q *Queries) CheckFollow(ctx context.Context, arg CheckFollowParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkFollow, arg.FollowerID, arg.FollowedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserID = `-- name: CheckUserID :one
SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)
`

func (q *Queries) CheckUserID(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsername = `-- name: CheckUsername :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = $1)
`

func (q *Queries) CheckUsername(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUsername, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createFollow = `-- name: CreateFollow :exec
INSERT INTO follows(follower_id, followed_id)
VALUES($1, $2)
ON CONFLICT(follower_id, followed_id) DO NOTHING
`

type CreateFollowParams struct {
	FollowerID uuid.UUID
	FollowedID uuid.UUID
}

func (q *Queries) CreateFollow(ctx context.Context, arg CreateFollowParams) error {
	_, err := q.db.ExecContext(ctx, createFollow, arg.FollowerID, arg.FollowedID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users(name, username, hashed_password, profile_image_url)
VALUES($1, $2, $3, $4)
RETURNING id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url
`

type CreateUserParams struct {
	Name            string
	Username        string
	HashedPassword  string
	ProfileImageUrl sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Username,
		arg.HashedPassword,
		arg.ProfileImageUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const deleteFollow = `-- name: DeleteFollow :exec
DELETE FROM follows WHERE follower_id = $1 AND followed_id = $2
`

type DeleteFollowParams struct {
	FollowerID uuid.UUID
	FollowedID uuid.UUID
}

func (q *Queries) DeleteFollow(ctx context.Context, arg DeleteFollowParams) error {
	_, err := q.db.ExecContext(ctx, deleteFollow, arg.FollowerID, arg.FollowedID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAllFollowers = `-- name: GetAllFollowers :many
SELECT users.id, users.name, users.username, users.hashed_password, users.joined_at, users.posts_count, users.following_count, users.followers_count, users.profile_image_url
FROM follows
JOIN users ON follows.follower_id = users.id
WHERE
    -- filter
    followed_id = $1 AND
    -- cursor
    (is_zero_uuid($3::UUID) OR id <= $3::UUID)
ORDER BY users.id DESC
LIMIT $2
`

type GetAllFollowersParams struct {
	FollowedID uuid.UUID
	Limit      int32
	ID         uuid.UUID
}

func (q *Queries) GetAllFollowers(ctx context.Context, arg GetAllFollowersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllFollowers, arg.FollowedID, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.HashedPassword,
			&i.JoinedAt,
			&i.PostsCount,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFollowersIDs = `-- name: GetAllFollowersIDs :many
SELECT follower_id FROM follows WHERE followed_id = $1
`

func (q *Queries) GetAllFollowersIDs(ctx context.Context, followedID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getAllFollowersIDs, followedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var follower_id uuid.UUID
		if err := rows.Scan(&follower_id); err != nil {
			return nil, err
		}
		items = append(items, follower_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url
FROM users
WHERE
     -- filter
    (name ILIKE '%' || $2::VARCHAR || '%' OR username ILIKE '%' || $3::VARCHAR || '%') AND
     -- cursor
    ($4::INTEGER = 0 OR followers_count <= $4::INTEGER) AND
    ($5::INTEGER = 0 OR posts_count <= $5::INTEGER) AND
    (is_zero_uuid($6::UUID) OR id <= $6::UUID)
ORDER BY
    followers_count DESC,
    posts_count DESC,
    id DESC
LIMIT $1
`

type GetAllUsersParams struct {
	Limit          int32
	Name           string
	Username       string
	FollowersCount int32
	PostsCount     int32
	ID             uuid.UUID
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers,
		arg.Limit,
		arg.Name,
		arg.Username,
		arg.FollowersCount,
		arg.PostsCount,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.HashedPassword,
			&i.JoinedAt,
			&i.PostsCount,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowersCount = `-- name: GetFollowersCount :one
SELECT COUNT(*) FROM follows WHERE followed_id = $1
`

func (q *Queries) GetFollowersCount(ctx context.Context, followedID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowersCount, followedID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url FROM users WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    name = $1,
    username = $2,
    hashed_password = $3,
    profile_image_url = $4
WHERE id = $5
RETURNING id, name, username, hashed_password, joined_at, posts_count, following_count, followers_count, profile_image_url
`

type UpdateUserParams struct {
	Name            string
	Username        string
	HashedPassword  string
	ProfileImageUrl sql.NullString
	ID              uuid.UUID
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Username,
		arg.HashedPassword,
		arg.ProfileImageUrl,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.HashedPassword,
		&i.JoinedAt,
		&i.PostsCount,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.ProfileImageUrl,
	)
	return i, err
}
