// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post.sql

package postgres_repo

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkBookmark = `-- name: CheckBookmark :one
SELECT EXISTS(SELECT 1 FROM bookmarks WHERE user_id = $1 AND post_id = $2)
`

type CheckBookmarkParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) CheckBookmark(ctx context.Context, arg CheckBookmarkParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkBookmark, arg.UserID, arg.PostID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkComment = `-- name: CheckComment :one
SELECT EXISTS(select 1 FROM post_comments WHERE id = $1)
`

func (q *Queries) CheckComment(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkComment, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPost = `-- name: CheckPost :one
SELECT EXISTS(select 1 FROM posts WHERE id = $1)
`

func (q *Queries) CheckPost(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkPost, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkReaction = `-- name: CheckReaction :one
SELECT EXISTS(SELECT 1 FROM post_reactions WHERE post_id = $1 AND user_id = $2)
`

type CheckReactionParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CheckReaction(ctx context.Context, arg CheckReactionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkReaction, arg.PostID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserOwnsComment = `-- name: CheckUserOwnsComment :one
SELECT EXISTS(select 1 FROM post_comments WHERE id = $1 AND user_id = $2)
`

type CheckUserOwnsCommentParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CheckUserOwnsComment(ctx context.Context, arg CheckUserOwnsCommentParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserOwnsComment, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserOwnsPost = `-- name: CheckUserOwnsPost :one
SELECT EXISTS(select 1 FROM posts WHERE id = $1 AND user_id = $2)
`

type CheckUserOwnsPostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CheckUserOwnsPost(ctx context.Context, arg CheckUserOwnsPostParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserOwnsPost, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBookmark = `-- name: CreateBookmark :exec
INSERT INTO bookmarks(user_id, post_id)
VALUES($1, $2)
ON CONFLICT(user_id, post_id) DO NOTHING
`

type CreateBookmarkParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, createBookmark, arg.UserID, arg.PostID)
	return err
}

const createComment = `-- name: CreateComment :one
INSERT INTO post_comments(post_id, user_id, content)
VALUES($1, $2, $3)
RETURNING id, post_id, user_id, content, created_at
`

type CreateCommentParams struct {
	PostID  uuid.UUID
	UserID  uuid.UUID
	Content string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, createComment, arg.PostID, arg.UserID, arg.Content)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createDislike = `-- name: CreateDislike :exec
insert into post_reactions(post_id, user_id, kind)
VALUES($1, $2, 'dislike')
ON CONFLICT(post_id, user_id) DO UPDATE 
SET kind = EXCLUDED.kind, created_at = NOW()
`

type CreateDislikeParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CreateDislike(ctx context.Context, arg CreateDislikeParams) error {
	_, err := q.db.ExecContext(ctx, createDislike, arg.PostID, arg.UserID)
	return err
}

const createLike = `-- name: CreateLike :exec
insert into post_reactions(post_id, user_id, kind)
VALUES($1, $2, 'like')
ON CONFLICT(post_id, user_id) DO UPDATE 
SET kind = EXCLUDED.kind, created_at = NOW()
`

type CreateLikeParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CreateLike(ctx context.Context, arg CreateLikeParams) error {
	_, err := q.db.ExecContext(ctx, createLike, arg.PostID, arg.UserID)
	return err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts(user_id, title, content, featured_image_url)
VALUES($1, $2, $3, $4)
RETURNING id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
`

type CreatePostParams struct {
	UserID           uuid.UUID
	Title            string
	Content          string
	FeaturedImageUrl sql.NullString
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.UserID,
		arg.Title,
		arg.Content,
		arg.FeaturedImageUrl,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.ViewsCount,
		&i.CommentsCount,
		&i.FeaturedImageUrl,
	)
	return i, err
}

const createReaction = `-- name: CreateReaction :exec
INSERT INTO post_reactions(post_id, user_id, kind_id)
VALUES($1, $2, $3)
ON CONFLICT(post_id, user_id) DO UPDATE
SET kind_id = EXCLUDED.kind_id
`

type CreateReactionParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
	KindID int32
}

func (q *Queries) CreateReaction(ctx context.Context, arg CreateReactionParams) error {
	_, err := q.db.ExecContext(ctx, createReaction, arg.PostID, arg.UserID, arg.KindID)
	return err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE user_id = $1 AND post_id = $2
`

type DeleteBookmarkParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) DeleteBookmark(ctx context.Context, arg DeleteBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, deleteBookmark, arg.UserID, arg.PostID)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM post_comments WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const deleteReaction = `-- name: DeleteReaction :exec
DELETE FROM post_reactions WHERE post_id = $1 AND user_id = $2
`

type DeleteReactionParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteReaction(ctx context.Context, arg DeleteReactionParams) error {
	_, err := q.db.ExecContext(ctx, deleteReaction, arg.PostID, arg.UserID)
	return err
}

const getAllBookmarks = `-- name: GetAllBookmarks :many
SELECT posts.id, posts.user_id, posts.title, posts.content, posts.created_at, posts.views_count, posts.comments_count, posts.featured_image_url
FROM bookmarks
JOIN posts ON bookmarks.post_id = posts.id
WHERE
    -- filters
    bookmarks.user_id = $1 AND
    -- cursor
    bookmarks.created_at <= coalesce(
        nullif($3::TIMESTAMP, '0001-01-01 00:00:00'::TIMESTAMP),
        now()
    )
ORDER BY bookmarks.created_at DESC
LIMIT $2
`

type GetAllBookmarksParams struct {
	UserID    uuid.UUID
	Limit     int32
	CreatedAt time.Time
}

func (q *Queries) GetAllBookmarks(ctx context.Context, arg GetAllBookmarksParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllBookmarks, arg.UserID, arg.Limit, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostComments = `-- name: GetAllPostComments :many
SELECT id, post_id, user_id, content, created_at
FROM post_comments
WHERE
    -- filters
    post_id = $1 AND
    -- cursor
    (is_zero_uuid($3::UUID) OR id <= $3::UUID)
ORDER BY id DESC
LIMIT $2
`

type GetAllPostCommentsParams struct {
	PostID uuid.UUID
	Limit  int32
	ID     uuid.UUID
}

func (q *Queries) GetAllPostComments(ctx context.Context, arg GetAllPostCommentsParams) ([]PostComment, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostComments, arg.PostID, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostComment
	for rows.Next() {
		var i PostComment
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many
SELECT id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
FROM posts
WHERE
    -- filters
    to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', $2::VARCHAR) AND
    -- cursor
    ($3::INTEGER = 0 OR views_count <= $3::INTEGER) AND
    (is_zero_uuid($4::UUID) OR id <= $4::UUID)
ORDER BY
    views_count DESC,
    id DESC
LIMIT $1
`

type GetAllPostsParams struct {
	Limit       int32
	SearchQuery string
	ViewsCount  int32
	ID          uuid.UUID
}

func (q *Queries) GetAllPosts(ctx context.Context, arg GetAllPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts,
		arg.Limit,
		arg.SearchQuery,
		arg.ViewsCount,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserPosts = `-- name: GetAllUserPosts :many
SELECT id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
FROM posts
WHERE
    -- filter
    user_id = $1 AND
    -- cursor
    (is_zero_uuid($3::UUID) OR id <= $3::UUID)
ORDER BY
    views_count DESC,
    id DESC
LIMIT $2
`

type GetAllUserPostsParams struct {
	UserID uuid.UUID
	Limit  int32
	ID     uuid.UUID
}

func (q *Queries) GetAllUserPosts(ctx context.Context, arg GetAllUserPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserPosts, arg.UserID, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarks = `-- name: GetBookmarks :many
SELECT posts.id, posts.user_id, posts.title, posts.content, posts.created_at, posts.views_count, posts.comments_count, posts.featured_image_url
FROM bookmarks
JOIN posts ON bookmarks.post_id = posts.id
WHERE bookmarks.user_id = $1
ORDER BY bookmarks.created_at
LIMIT $2
OFFSET $3
`

type GetBookmarksParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetBookmarks(ctx context.Context, arg GetBookmarksParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarks, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarksCount = `-- name: GetBookmarksCount :one
SELECT COUNT(*) FROM bookmarks WHERE user_id = $1
`

func (q *Queries) GetBookmarksCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBookmarksCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPost = `-- name: GetPost :one
SELECT id, user_id, title, content, created_at, views_count, comments_count, featured_image_url FROM posts WHERE id = $1
`

func (q *Queries) GetPost(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.ViewsCount,
		&i.CommentsCount,
		&i.FeaturedImageUrl,
	)
	return i, err
}

const getPostComments = `-- name: GetPostComments :many
SELECT id, post_id, user_id, content, created_at
FROM post_comments
WHERE post_id = $1
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type GetPostCommentsParams struct {
	PostID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetPostComments(ctx context.Context, arg GetPostCommentsParams) ([]PostComment, error) {
	rows, err := q.db.QueryContext(ctx, getPostComments, arg.PostID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostComment
	for rows.Next() {
		var i PostComment
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostCommentsCount = `-- name: GetPostCommentsCount :one
SELECT comments_count FROM posts WHERE id = $1
`

func (q *Queries) GetPostCommentsCount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPostCommentsCount, id)
	var comments_count int32
	err := row.Scan(&comments_count)
	return comments_count, err
}

const getPostReactions = `-- name: GetPostReactions :many
SELECT 
    rk.name,
    COUNT(pr.kind_id) AS count
FROM post_reactions pr
JOIN reaction_kinds rk ON pr.kind_id = rk.id
WHERE pr.post_id = $1
GROUP BY pr.kind_id, rk.name
`

type GetPostReactionsRow struct {
	Name  string
	Count int64
}

func (q *Queries) GetPostReactions(ctx context.Context, postID uuid.UUID) ([]GetPostReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostReactions, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostReactionsRow
	for rows.Next() {
		var i GetPostReactionsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostViews = `-- name: GetPostViews :many
SELECT users.id, users.name, users.username, users.hashed_password, users.joined_at, users.posts_count, users.following_count, users.followers_count, users.profile_image_url
FROM post_views
JOIN users ON post_views.user_id = users.id
WHERE post_id = $1
ORDER BY post_views.created_at
LIMIT $2
OFFSET $3
`

type GetPostViewsParams struct {
	PostID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetPostViews(ctx context.Context, arg GetPostViewsParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getPostViews, arg.PostID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.HashedPassword,
			&i.JoinedAt,
			&i.PostsCount,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostViewsCount = `-- name: GetPostViewsCount :one
SELECT views_count FROM posts WHERE id = $1
`

func (q *Queries) GetPostViewsCount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPostViewsCount, id)
	var views_count int32
	err := row.Scan(&views_count)
	return views_count, err
}

const getReactionKindIDByName = `-- name: GetReactionKindIDByName :one
SELECT id FROM reaction_kinds WHERE name = $1
`

func (q *Queries) GetReactionKindIDByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getReactionKindIDByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getUserPosts = `-- name: GetUserPosts :many
SELECT id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
FROM posts
WHERE user_id = $1
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type GetUserPostsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetUserPosts(ctx context.Context, arg GetUserPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getUserPosts, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.ViewsCount,
			&i.CommentsCount,
			&i.FeaturedImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPostsCount = `-- name: GetUserPostsCount :one
SELECT posts_count FROM users WHERE id = $1
`

func (q *Queries) GetUserPostsCount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserPostsCount, id)
	var posts_count int32
	err := row.Scan(&posts_count)
	return posts_count, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE post_comments
SET content = $1
WHERE id = $2
RETURNING id, post_id, user_id, content, created_at
`

type UpdateCommentParams struct {
	Content string
	ID      uuid.UUID
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, updateComment, arg.Content, arg.ID)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET 
    title = $1,
    content = $2,
    featured_image_url = $3
WHERE id = $4
RETURNING id, user_id, title, content, created_at, views_count, comments_count, featured_image_url
`

type UpdatePostParams struct {
	Title            string
	Content          string
	FeaturedImageUrl sql.NullString
	ID               uuid.UUID
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.Title,
		arg.Content,
		arg.FeaturedImageUrl,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.ViewsCount,
		&i.CommentsCount,
		&i.FeaturedImageUrl,
	)
	return i, err
}

const viewPost = `-- name: ViewPost :exec
INSERT INTO post_views(post_id, user_id)
VALUES($1, $2)
ON CONFLICT(post_id, user_id) DO NOTHING
`

type ViewPostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) ViewPost(ctx context.Context, arg ViewPostParams) error {
	_, err := q.db.ExecContext(ctx, viewPost, arg.PostID, arg.UserID)
	return err
}
